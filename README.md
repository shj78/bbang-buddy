<p align="center">
  <img width="341" height="189" alt="bbd" src="https://github.com/user-attachments/assets/dc80f415-9bc0-4ce1-8b9a-d02644b4161a" />
</p>
<hr>

<h4 align="center">
  <a href="https://bbangbuddy.com">🌐 Home</a>
</h4>
<div align="center">
  <p>
    <a href="https://github.com/shj78/bbang-buddy">
      <img alt="Last commit" src="https://img.shields.io/github/last-commit/shj78/bbang-buddy?style=for-the-badge&logo=starship&color=8bd5ca&logoColor=D9E0EE&labelColor=302D41"/>
    </a>
    <a href="https://github.com/shj78/bbang-buddy">
      <img alt="Issues" src="https://img.shields.io/github/issues/shj78/bbang-buddy?style=for-the-badge&logo=bilibili&color=F5E0DC&logoColor=D9E0EE&labelColor=302D41" />
    </a>
      <a href="https://github.com/shj78/bbang-buddy">
      <img alt="Repo Size" src="https://img.shields.io/github/repo-size/shj78/bbang-buddy?color=%23DDB6F2&label=SIZE&logo=codesandbox&style=for-the-badge&logoColor=D9E0EE&labelColor=302D41" />
    </a>
  </p>
</div>

#### 부제: N빵의 민족

> **빵버디는 동네 사람들과 함께하는 위치 기반 공동구매 플랫폼 서비스 입니다.**

사용자 허용에 따른 내 위치 반경 3km의 공동구매 팟을 실시간으로 탐색하고 참여합니다. </br>
</br>
1인 가구 수요를 고려해 홍익대학교 중심 근처 선택할 수 있는 지하철역을 우선 배치했으며, 이외 지역 또한 수동으로 위치를 선택할 수 있습니다. </br>
지도 기반 UI, 실시간 알림을 통해 직관적이고 편리한 구매 공동구매 경험을 제공합니다.

주거공간 대비 적절한 양의 구매와 쌓아만 둔 생필품, 식료품을 버리지 않고 </br>
나누고 싶은 개인적 니즈와 1인 가구 증가, 불필요한 소비에 대한 사회적인 관심으로 기획했습니다. </br>
</br>

## 🗺️ 목&nbsp;차

#### &nbsp; 1. 데모 영상

#### &nbsp; 2. 여러가지 고민의 배경과 접근, 해결, 회고

#### &nbsp; 3. 어려웠던 점

#### &nbsp; 4. 실패와 배운점

#### &nbsp; 5. 기술 선정 이유

#### &nbsp; 6. UI 아키텍쳐

<br>
<br>

### 1. 데모 영상
![수동위치선택](https://github.com/user-attachments/assets/8600077d-7995-460c-9aa0-7f07c305baae)
![팟참여](https://github.com/user-attachments/assets/13853863-4df5-44a3-be19-1f753d8a5b75)
![나의팟](https://github.com/user-attachments/assets/c53c75c8-e6c8-4601-b05e-bd5b5c5e0464)
![채팅방연동](https://github.com/user-attachments/assets/e2460de4-894c-4048-8cf0-59e833ac7027)

</br>
</br>
</br>

### 2. 여러가지 고민의 배경과 접근, 해결, 회고

#### 고민 1) 편리하게 팟에 참여하는 방법

##### 배경

빵버디는 사용자의 **팟 참여 경험이** 서비스 만족도를 결정짓는 핵심 요소입니다.
그렇기 때문에 사용자가 팟에 참여할 때 거리나 위치를 쉽게 비교하고, 직관적으로 접근할 수 있도록 만드는 것이 중요했습니다.

##### 접근

사용자가 팟 참여를 결정할 때 가장 크게 영향을 받는 요소는 ‘거리’라고 판단했습니다. 내 위치를 기준으로 주변 팟의 거리와 위치를 시각화해, 지도를 통해 자연스럽게 팟을 탐색하고 참여를 유도하는 방향으로 설계했습니다.

##### 해결

**Naver Map + Kakao Map API**

- 대중적인 Naver Map을 이용해 지도 및 위치 기반 UI 구현
- Naver Map에서 위도·경도로 주소 변환이 제한된 부분은 Kakao Map API로 보완

##### 회고

빵버디를 처음 사용하는 사용자 입장으로 서비스를 고민하며, 직관과 논리를 바탕으로 가설을 세우고 구현을 통해 검증할 수 있었습니다.
<br>
<br>
<br>

#### 고민 2) 한 위치에 여러 팟이 생성될 수 있는 문제

##### 배경

홍대입구역같이 많은 사람이 모이는 장소일 경우 같은 경도 위도를 가진 여러개의 팟 마커가 중복될 수 있어 마커 외 다른 처리가 필요했습니다.

##### 접근

Naver Map API를 커스터마이징하는 안과 마커의 그룹핑 기능이 지원되는 지에 대해 조사했습니다.

##### 해결

**클러스터링**

- 여러 마커를 하나의 아이콘으로 묶어 보여주는 클러스터링 기능을 이용해 중복되는 팟의 경우 그룹핑
- 클러스터링된 버튼을 클릭 시 그룹핑된 팟을 진행중인 팟과 마감된 팟으로 분기해 리스트를 출력하는 팝업으로 처리

##### 회고

- 클러스터링이라는 개념을 새롭게 적용해보며 지도 데이터의 효율적인 시각화 방법을 배웠습니다.
- 팝업 UI의 위치를 마커 위치로 조정하는 과정에서는 마커 좌표를 기준으로 배치했을 때 지도 영역을 벗어나는 문제가 발생해 팝업을 지도 화면의 수평, 수직 정중앙에 배치하는 방식으로 해결했습니다. 이 과정에서 어떤 DOM 영역을 기준으로 팝업 위치를 계산해야할 지, 커서의 이동 시 팝업이 어떻게 반응해야하는 지 고민했습니다. 이 경험을 통해 렌더링 좌표계와 실제 뷰포트 간의 차이를 이해하게 되었습니다.
  </br>

#### 고민 3) 내 위치는 현재 서울인데 부산의 팟까지 맵에 마커가 로딩되는 문제

##### 배경

로컬 환경에서 팟의 로딩 속도가 느려서 확인해보니 테스트 데이터의 모든 팟이 로딩되는 문제가 있었습니다.

##### 접근

사용자 위치 기준 근처 팟을 참여하는 서비스이기 때문에 km 반경의 팟만 지도 내에 로딩되도록 기준 값을 지정했습니다.

##### 해결

**공간함수**

- 공간함수를 이용해 위도와 경도 기준으로 km 값 반경의 위도와 경도를 계산 후 해당 범위의 팟만 지도에 로딩되도록 마커를 필터링

##### 회고

- 위치 기반 범위 계산 방법을 통해 지도 데이터 최적화와를 경험했습니다.
- 이 과정에서 마커 데이터는 내 위치 좌표를 query key로 Tanstack Query에 캐싱했고, 불필요한 요청을 방지하는 성능 최적화 경험을 쌓았습니다.
  </br>

#### 고민 4) 실시간 팟 참여를 위한 플로우

##### 배경

실시간 참여를 위한 팟 참여자간의 채팅방과 팟 참여자간 알림이 필요했습니다.

##### 접근

빵버디 자체 채팅 기능 개발과 대중적으로 이용되고 익명이 보장되는 카카오톡 오픈채팅방 링크를 연동하는 방식을 고민했습니다. 알림의 경우는 익숙한 Websocket과 SSE를 이용하는 방식을 고민했습니다.

##### 해결

**Telegram Bot API와 카카오톡 오픈 채팅방 링크 연동**

- 운영자에게 팟 생성 시, 팟 참여자가 발생할 시 링크 생성 요청 메시지를 발송하고 확인 후, 운영자는 채팅방 링크 생성
- 채팅 기능을 만드는 것은 추후 기능 개발 시 진행할 예정으로 서비스의 본질적인 목적에 집중
- 봇의 경우 LINE 봇과 Telegram 봇을 고민했으나 deprecated 기간을 고려해 텔레그렘 봇을 선택
  **SSE 기반 알림**
- 단방향의 알림만 필요하기 때문에 SSE를 사용해 팟 참여자가 발생할 시 알림을 전송하는 방식으로 구현했습니다.

##### 회고

- 외부 서비스 연동을 통한 실시간 알림 처리를 경험했습니다.
- 운영자와 시스템 간의 자동화 플로우를 고민하며 실시간 참여 경험을 지원하는 프론트엔드 설계 기반을 쌓을 수 있었습니다.
  </br>

#### 고민 5) 크롬의 지오로케이션 캐싱 이슈로 웹에서 내 위치 인식 문제

##### 배경

모던 브라우저를 이용해 크롬 내 위치 허용을 설정하고 있는 상태에서 위치가 인식되지 않아 지오로케이션 API 좌표의 기본값인 시청역으로 위치가 설정되는 문제가 있었습니다.

##### 접근

웹이든 모바일이든 매체 상관없이 위치 설정이 가능한 기능을 구현해야한다는 점으로 고민했습니다.

##### 해결

**서비스 오픈 지역을 고려한 좌표 설정과 위치 선택**

- 웹에서 위치가 잡히지 않을 경우 서비스 오픈 지역 내 기본값으로 설정된 위도와 경도로 셋팅
- 위치 선택 버튼을 지도 위 플로팅시켰고 지정된 몇개의 지하철역 또는 수동 위치 지정 커서를 통한 위치 선택 유도

##### 회고

- 웹에서 지오로케이션 캐싱 이슈는 브라우저 캐싱, HTTPS가 아닌 경우 위치 요청을 제한하는 보안 정책, 브라우저의 위치 추정 방법(Wi-Fi, IP, 기지국)에 의해 발생한다는 점을 알 수 있었습니다.
- 이 과정에서 웹과 모바일 환경의 차이를 이해하고 위/경도 기반 서비스에서의 위치를 처리할 경우 기본값, 수동 위치 선택 기능등 다양한 경우를 고려해야한다는 점을 깨달았습니다.
  </br>

#### 고민 6) 팟 참여 페이지 LCP 개선

##### 배경

팟 참여 페이지의 **LCP(Largest Contentful Paint)가 4초 이상** 소요되어, 사용자 경험 개선이 필요했습니다.

##### 접근

Next.js의 성능 최적화 기능을 활용하고, **성능 측정 → 개선 → 재측정** 과정을 반복하며 시도했습니다.

##### 해결

**지연 로딩**

- 지도 SDK, API 로딩을 하는 컴포넌트를 Suspense를 이용한 지연 로딩 처리
  **useMemo**
- 마커 데이터가 변경되지 않을 경우 컴포넌트가 리렌더링 되더라도 불필요한 마커들의 재로딩 방지
  **Script 로딩 전략**
  외부 Web API의 경우 수화 이전 로딩이 필요없기 때문에 afterInteractive 전략을 명시
  **이미지 및 폰트, 링크 최적화**
- 이미지: priority 속성을 추가해 프리로딩, 규격 명시로 CLS 방지
- 폰트: 다국어 폰트 전체가 아닌 한국어 폰트만 로딩되도록 설정해 초기 폰드 다운로드의 크기를 최소화
- 링크: 자주 방문하거나 흐름상 열릴 가능성이 높은 페이지를 사전 프리로드해 라우팅 지연 방지

##### 회고

- LCP를 4초 이내로 단축하며, Next.js 성능 최적화 기능의 활용법과 효과를 직접 체감했습니다.
- 이를 통해 프론트엔드 성능 개선 과정에서 렌더링 병목 파악과 최적화 전략 적용 경험을 쌓을 수 있었습니다.
  </br>

#### 고민 7) 스프링 시큐리티와 Firebase, Kakao 로그인 구현과정에서 각각 다른 토큰 형식과 알고리즘

##### 배경

스프링 시큐리티와 Firebase, Kakao 로그인 구현과정에서 각각 다른 토큰 형식과 복호화 알고리즘으로 인해 인증 과정에서 문제가 발생했습니다.

##### 접근

다른 알고리즘이라도 동일하게 복호화하고 다른 토큰 형식이라도 동일하게 인증되는 방법을 고민했습니다.

##### 해결

**토큰 통일**

- 빵버디만의 형식을 가진 토큰으로 일괄 적용
- 다른 알고리즘일 경우 로직을 분기해 복호화

##### 회고

- 서로 다른 인증 파이프라인을 사용할 경우 인증 스펙이 각기 다를 수있는 가능성을 열어두고 로직을 분기하거나, 토큰/알고리즘의 표준화에 대한 기준을 세워 판단하고 설계해야한다는 교훈을 얻었습니다.
  </br>

#### 고민 8) API 에러, 로딩을 리액트 상태 관리로 관리하며 일일이 처리하는 문제

##### 배경

API 에러, 로딩을 useState로 관리하며 유지보수, 개발자 경험의 문제가 있었습니다.

##### 접근

리액트 공식문서가 권고하듯이 에러, 로딩 상태 지원 라이브러리를 사용하는 방향으로 고민했습니다.

##### 해결

**TanStack Query**

- useQuery, useMutation을 이용
- 번거로운 에러, 로딩 useState 설정 로직 제거

##### 회고

반복되는 에러, 로딩 상태 관리를 라이브러리에 위임하며 비즈니스 로직과 화면 구성에 더 집중할 수 있었습니다.
</br>
</br>
</br>
</br>

### 3. 어려웠던 점

- Map SDK 로딩 시점에 맞춰 로딩한 데이터를 지도 위 마커로 셋팅하는 비동기 로직<br>
  : script와 useEffect를 사용해 지도 위 마커가 렌더링되지 않는 문제가 발생했습니다. 네이버 맵 SDK와 팟 마커 렌더링 간의 비동기 타이밍 이슈라고 판단 후, 해결책으로 Next.js Script의 프리로드 기능으로 SDK를 우선 로드하고, Suspense + lazy import로 NaverMap 컴포넌트를 지연 로딩했습니다. MapOverlay에서는 팟 데이터를 비동기로 가져와 마커를 렌더링하여 SDK 로딩 완료 후 정상적으로 마커가 표시되도록 구현했습니다.

- 구독 요청이 완료된 SSE가 전송된 알림을 전달하지 못하는 문제<br>
  : 기본 API 호출 방식으로 SSE에 잘못 접근했습니다. SSE의 eventSource에는 기본적으로 헤더가 없기 때문에 헤더에 토큰을 추가하는 방식으로는 토큰 전달이 안된다는 점을 인지하고 URL 파라미터 방식으로 변경해 해결했습니다.
- 이미지 저장 시 이미지가 octet-stream으로 인식되어 저장되지 않는 문제
  : 이미지가 포함된 FormData 전송 시 Content-Type에 application/json 헤더가 설정되어 파일이 octet-stream으로 인식, boundary 값이 없어 서버에서 파싱 오류가 발생했습니다. 해결책으로 FormData가 요청 객체일 경우, Content-Type 헤더를 삭제하고 axios가 자동으로 multipart/form-data; boundary를 설정하도록해 파일 업로드를 정상화했습니다.
- 개발/운영 DB 분리 셋팅<br>
  : 기존에 DB를 셋팅하던 방식대로 Oracle Cloud 프리티어를 이용해 Datagrip, IntelliJ 내장 DB, Docker 셋팅을 시도했으나 불가능했습니다. Oracle Cloud에서 제공되는 프리티어 DB는 Datagrip에 연결이 되지 않으며, sql developer만 이용 가능합니다. 마찬가지로 Docker, IntelliJ 내장된 DB 셋팅에도 연결이 불가했습니다. 그래서 지원되는 방식을 확인하고 개발과 운영 환경을 분리했습니다.
  - 개발은 H2 DB로 개발 환경을 구성해 H2의 모드에 따른 Memory/File/TCP 접속 방식과 Spring Boot와 구동 시점에 따른 차이를 이해하는데 초기 진입 장벽을 경험했습니다.
  - 운영은 sql developer를 이용해 운영 환경을 구성해 클라우드 지갑이라는 개념을 이해하고,sqlnet과 tnsnames.ora 파일 설정과 오라클 클라우드 네트워크 포트 환경 구성을 학습해 적용했습니다.
- 네트워크 포트 환경구성 이슈로 웹이 NginX 기본 페이지만 노출되는 문제<br>
  : OCI VM 내 네트워크의 보안 그룹, 보안 목록, Ingress Rule 설정 시 destination을 80 포트로 지정하지 않고 모든 포트로 설정하여 문제가 발생했습니다. 모든 포트가 열리면서 불안정을 감지한 프록시와 NginX 구조가 깨져 내부적으로 의도한 경로를 우회했고, 그 우회로 인해 NginX 기본 페이지만 노출되는 현상이 발생했습니다. destination을 80 단일 포트로 수정하여 정상적인 웹 애플리케이션 접근이 가능하도록 해결했습니다.
  </br>
  </br>
  </br>

### 4. 실패와 배운점

- 고민 4로 접근했던 부분이 새벽 시간에는 운영자가 부재중일 수 있어 오랜 시간 채팅방 생성이 지연
  : 채팅방 생성 시에는 시간이나 외부 환경에 상관없이 서비스 사용자는 채팅방의 이용이 자유로워야 한다는 점을 배울 수 있었습니다. 추후 빵버디 서비스 내 채팅 기능을 구현해 적용할 예정입니다.

- 오라클 VM 설치 과정 중 램 1GB 이슈로 VM 재설치
  : 15GB로 설치하는 과정에서 램이 1GB로 설치가 된 것을 확인했습니다. 15를 작성하는 과정에서 1이 들어갔던 것으로 결론이 났고, 재설치를 진행했습니다. 실무에서는 사소한 실수가 큰 문제를 발생시킬 수 있기 때문에 VM 생성 시 신중하게 선택하고 확인하는 것이 필요하다는 점을 다시 한번 배웠습니다.
  </br>
  </br>
  </br>

## 5. 기술과 선정 이유

### **프론트엔드**

- **Framework**: Next.js 15
  - 초기 로딩이 중요한 서비스라고 생각했기 떄문에 LCP 개선을 위해 Next.js를 선택했습니다. 뿐만 아니라 이미지, 폰트 최적화와 로딩 제어같은 빌트인 기능이 있어 전체 성능을 끌어올리기 수월할 것으로 판단했습니다.
- **UI Library**: React 19
  - 컴포넌트 기반으로 재사용성과 풍부한 생태계가 있어 빠른 개발과 Next.js와의 호환으로 RSC를 결합한 성능 개선도 가능할 것이라고 생각했습니다. 대안은 Vue가 있었으나 Next.js와 시너지를 우선순위로 설정해 선택했습니다.
- **TypeScript**: 유지보수성과 DX를 고려했을 때, Javascript 보다 초기 러닝커브가 있지만 장기적으로 버그나 개발속도에 이점이 있다고 판단해 선택했습니다.
- **State Management**:
  - Zustand: 클라이언트 상태 관리 전략으로 개인 프로젝트에 적용할만한 경량성과 낮은 러닝 커브를 중점으로 선택했습니다. 복잡한 클라이언트의 전역 상태를 관리해야할 경우 Redux를 선택할 수 있었지만 앱의 규모에 따라 결정했습니다.
  - TanStack Query: 서버 데이터의 캐싱, 동기화, 에러와 로딩상태를 지원하기 때문에 데이터의 일관성과 유지보수성을 개선할 수 있을 거라고 생각해 선택했습니다.
- **Maps**: Naver Maps API, Kakao Maps API
  - Kakao Map API의 사용 경험이 있어 두 지도 API의 차이점을 알고 적절히 선택하고자 Naver Map API를 선택했습니다.
- Alarm: SSE
  - 단방향 알림을 위해 SSE를 선택했습니다. SSE는 가볍고 단방향 통신에 적합한 방식이고, 대안과 경험으로는 Websocket을 선택할 수 있었지만, 앱에 적절한 기술을 고려해 선택했습니다.
- **Styling**: MUI
  - 빠른 개발과 디자인 요소를 고려해 MUI를 선택했습니다. 이미 Tailwind CSS를 사용해본 경험이 있었지만, 디자인 시스템 관점에서 컴포넌트 수준의 재사용성과 접근성 지원, 테마 커스터마이징이 용이하다고 판단해 선택했습니다.

### **인프라 & 모니터링**

- **Error Tracking**: Sentry
- **Authentication**: Firebase, Kakao Login API, Spring Security
- **Deployment**: Oracle Cloud Infrastructure VM
- **Package Manager**: pnpm

### **이외**

- **Linting**: ESLint
- **Date Handling**: dayjs
- **HTTP Client**: Axios
- **Toast Notifications**: Sonner

### **상태 관리 전략**

- **Zustand**: 클라이언트 상태 (인증, 위치, 알림)
- **TanStack Query**: 서버 상태 (팟 데이터, 사용자 정보)
- **쿠키**: JWT 토큰 저장 (자동 API 인증)
- **localStorage**: 사용자 정보 캐싱 (페이지 새로고침 대응)

### 최적화와 개선

#### **성능 최적화**

- Next.js App Router 기반 파일 라우팅과 컴포넌트 분리로 페이지별 최적화된 번들링
- 지도·인증·알림 기능의 독립적 로딩을 통한 사용자 진입 경험 향상
- TanStack Query를 통한 API 캐싱·자동 갱신으로 서버 상태 동기화 및 실시간 알림 흐름 최적화

#### **개발 경험 개선**

- Custom Hook을 통해 비즈니스 로직과 UI를 분리하고 컴포넌트 재사용성 극대화
- Zustand로 클라이언트 상태를 전역 관리하여 불필요한 리렌더링 최소화 및 UI 일관성 확보
- TypeScript 기반 타입 안전성 확보 및 개발 생산성 향상

#### **사용자 경험 개선**

- Geolocation API 기반 위치 자동 감지 및 수동 위치 설정 지원
- SSE 기반 실시간 알림으로 팟 참여/탈퇴 현황 즉시 반영
- Material-UI 기반 반응형 디자인으로 모바일/데스크톱 환경 최적화
  </br>
  </br>
  </br>

## 6. UI 아키텍처

### 예정

- 아래는 현재 구조로, Atomic Desgin 패턴과 Featured Structed Design 고민중, 컴포넌트들이 도메인 별 분리가 되어있는 점에서 FSD로 선택해 마이그레이션 예정입니다.

```
src/
├── app/                    # Next.js App Router 페이지
├── components/
│   ├── auth/              # 인증 관련 컴포넌트
│   ├── client/            # 클라이언트 컴포넌트 래퍼
│   ├── map/               # 지도 관련 컴포넌트
│   ├── pot/               # 팟 관련 컴포넌트
│   └── ui/                # 공통 UI 컴포넌트
├── hooks/                 # Custom Hook
├── store/                 # Zustand 전역 상태
├── lib/                   # API 클라이언트
├── utils/                 # 유틸리티 함수
├── theme/                 # 테마
├── style/                 # 스타일
├── constants/             # 상수
├── utils/                 # Provider 모음
└── types/                 # TypeScript 타입 정의
```

**개발 기간**: 2025.06 - 2025.07
**개발자**: 심혜진
